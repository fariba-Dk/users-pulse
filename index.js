const express = require('express');
const mongoose = require('mongoose');
const cookieSession = require('cookie-session'); //require c-s module give access to cookies
const passport = require('passport');//need to require passport libraries = makes use of cookies
const GoogleStrategy = require('passport-google-oauth20').Strategy;
const keys = require('./config/keys');
require('./models/User');

//we hide mongoURI in our keys.js
mongoose.connect(keys.mongoURI, {
  useNewUrlParser: true,
  useCreateIndex: true,
  useUnifiedTopology: true,
});

const app = express();

//it tell express to use cookie inside express
//watch optional video for passport functionality in 50 of the recording
app.use(
  cookieSession({ //
    maxAge: 30 * 24 * 60 * 60 * 1000, //how long cookie will exist before we expire it -- needs to be in millisecond
    keys: [keys.cookieKey], //WE GET THIS FROM keys.js - this key is used to encrypt out cookie
  })
);
app.use(passport.initialize());
app.use(passport.session()); //48

//out of mongoose this is our model class to create an instance  and feed to db
const User = mongoose.model('users'); // we are fetching out of mongoose
//in User.js in  models we crated a user schem and we loaded the schema into mongoose we are
//2 args loads into mongoose

//this FUNCTION is called automatically by passport with our user model that we just FETCHED  makes token
passport.serializeUser((user, done) => {
  //watch session 45 for different kind if id's by google auth and also by  internal mongo
  //this is the user from our db
  done(null, user.id); //this is the id generated by mongo
});

passport.deserializeUser((id, done) => { //we are passing
  User.findById(id).then((user) => {
    done(null, user);
  });
});
//new GoogleStrtegy it creates a new instance of GoogleStratey
//passport.use = passport makes use of authentication possible
//oauth process with route handler

passport.use(
  new GoogleStrategy(
    {
      clientID: keys.googleClientID,
      clientSecret: keys.googleClientSecret,
      callbackURL: '/auth/google/callback',
    },
    //we need to have access this is a callback function
    (accessToken, refreshToken, profile, done) => {
      console.log('THIS is access token ->>', accessToken);
      console.log('THIS IS A refresh token ---->', refreshToken);
      console.log('THIS IS USER profile ---------->', profile);
      //ASYNC
      //done tells passport we are finished with new user or existing user
      //this call back -> either retrieve the user model or create a new one
      User.findOne({ googleId: profile.id }).then((existingUser) => {
        //anytime we reach out to mongo db it is an asyncronous action
        //if anyone has used this profile.id
        if (existingUser) { //a model instance that reprents a moded
          //initiate a query to see if an id already exists to keep
          done(null, existingUser);
        } else {
          new User({ googleId: profile.id })
            .save()//it takes that model instance and save it fo rus
            .then((user) => done(null, user));
          //we create a new instance of user
        }
      });
    }
  ) // console.log('access token', accessToken);
  // console.log('refresh token', refreshToken);
  // console.log('profile:', profile);
);

app.get(
  '/auth/google',
  //internal identifier if google exists use the passport process
  passport.authenticate('google', {
    scope: ['profile', 'email'], //we can indicate whatever we want in this arr
  })
);

//user get the code so the user has already authenticated
app.get('/auth/google/callback', passport.authenticate('google'));
app.get('/api/logout', (req, res)=>{
  req.logout()//attaches automatically itself to the user cookie to destory it
  res.send("you are logged out")
})

app.get('/api/current_user', (req, res) => {
  res.send(req.user); //this will test if someone has already gone thru authentication
});

const PORT = process.env.PORT || 4960;
app.listen(PORT);

//http is stateless
//ajax request is http
//between any two request, http has no way to distinguish i
//informations between requests are not shared so
//header is going to have a cookie
//when browser sees this it is going to store it and going to store it in browser and append it

//COOKIE BASED AUTHENTICATION
// the entire key of authentication is to place an identifying info in the cookie so browser includes the cookie in the request and since it matches then it allows it
//CONS:
